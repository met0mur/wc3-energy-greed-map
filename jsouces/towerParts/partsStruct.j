library partsStruct uses general {			/*		определям размер массива деталей	*/	#define maxTowerLevel=15;	#define maxPartsPerConfig=25;	#define maxPartsPerTower=20;		private keyword PartConfigStruct;	public keyword TowerSetStruct;	private keyword TowerPartStruct;		/*		Список конфигов башен		(1 тип башни = 1 конфиг)	*/		private PartSetConfigStruct array list;	private integer pointer = 0;		/*		PartSetConfigStruct		Описывает 1 тип башни с несколькими уровнями апгрейда и множеством визуальных деталей		(1 тип башни = N уровней + N деталей)	*/		struct PartSetConfigStruct {					/*			Collections		*/				private integer array towerIDS[maxTowerLevel];		private integer tower_pointer = 0;				private PartConfigStruct array parts[maxPartsPerConfig];		private integer parts_pointer = 0;				/*			Public methods		*/				public nothing addTower(integer towerId) {			towerIDS[tower_pointer] = towerId;			tower_pointer++;		}				public nothing addPart(integer partId, integer minLevel, integer maxLevel) {			PartConfigStruct part = PartConfigStruct.create();			part.setData(partId, minLevel, maxLevel);			this.parts[parts_pointer] = part;			this.parts_pointer++;		}				public nothing lastPartOffset(real x, real y, real r) {			PartConfigStruct part = this.parts[parts_pointer-1];			part.x = x;			part.y = y;			part.r = r;		}				public boolean isValidTarget(unit target) {			return this.getTargetLevel(target) > 0;		}				/*Создаёт инстанс конкретного набора деталей для конкретного уровня башни*/				public TowerSetStruct createTowerSetStruct(unit target) {			integer level = this.getTargetLevel(target);			if (level == 0) {				return 0;			}			TowerSetStruct towerSet = TowerSetStruct.create();			integer i = parts_pointer;			whilenot (i-- == 0) {				PartConfigStruct partConf = parts[i]; 				if (level >= partConf.minLevel and level <= partConf.maxLevel) {					TowerPartStruct part = TowerPartStruct.create();					part.init(target, partConf);					towerSet.addPart(part);				}			}			return towerSet;		}				/*			Private methods		*/				private integer getTargetLevel(unit target) {			integer unitType = GetUnitTypeId(target)			integer i = tower_pointer;			whilenot (i-- == 0) {				if (towerIDS[i]==unitType) {					return i+1;				}			}			return 0;		}	}		/*		PartConfigStruct		Описывает 1 визуальную деталь для нескольких уровней башни	*/		private struct PartConfigStruct {				/*			Variables		*/				public integer partId;		public integer minLevel;		public integer maxLevel;		public real x = 0;		public real y = 0;		public real r = 0;				/*			Public methods		*/				public nothing setData(integer partId, integer minLevel, integer maxLevel) {			this.partId = partId;			this.minLevel = minLevel;			this.maxLevel = maxLevel;		}	}		/*		TowerSetStruct		Описывает набор существующих деталей одного уровня башни	*/		public struct TowerSetStruct {				/*			Variables		*/				private unit owner;		private TowerPartStruct array parts[maxPartsPerTower];		private integer parts_pointer = 0;				/*			Public methods		*/				public nothing addPart(TowerPartStruct part) {			parts[parts_pointer] = part;			parts_pointer++;		}				public nothing applyOffset() {			integer i = parts_pointer;			whilenot (i-- == 0) {				parts[i].applyOffset();			}		}				nothing onDestroy() {			integer i = parts_pointer;			whilenot (i-- == 0) {				parts[i].destroy();			}			parts_pointer = 0;		}	}		/*		TowerPartStruct		Описывает существующую деталь башни	*/		private struct TowerPartStruct {				/*			Variables		*/				private unit target;		private unit part;		private PartConfigStruct config;				/*			Public methods		*/				public nothing init(unit target, PartConfigStruct conf) {			this.config = conf;			this.target = target;			this.part = CreateUnit(GetOwningPlayer(target), conf.partId, conf.x, conf.y, conf.r);			this.applyOffset();		}				public nothing applyOffset() {			SetUnitX(this.part, GetUnitX(this.target) + this.config.x);			SetUnitY(this.part, GetUnitY(this.target) + this.config.y);			SetUnitFacing(this.part, config.r);		}				nothing onDestroy() {			RemoveUnit(part);		}	}		/*		Конфигурирование		Создаёт новый конфиг и добавляет его в список	*/		public PartSetConfigStruct writeNewPartSetConfig() {		PartSetConfigStruct conf = PartSetConfigStruct.create();		list[pointer] = conf;		pointer++;		return conf;	}		/*		Создаёт новый набор деталей	*/		public TowerSetStruct checkAndCreate(unit target) {		integer i = pointer;		whilenot (i-- == 0) {			if (list[i].isValidTarget(target)) {				return list[i].createTowerSetStruct(target);			}		}		return 0;	}}